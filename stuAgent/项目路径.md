
好的，我们来规划一条清晰、可执行的项目实现路径，并为你推荐一套主流且强大的技术选型。

这条路径将遵循“**先稳固、后智能，先核心、后扩展**”的原则，确保项目根基扎实，便于未来迭代。

### 项目实现路径：三步走战略

我们将项目分为三个主要阶段，每个阶段都有明确的目标和产出。

---

#### **第一阶段：构建数据基石 (MVP - 最小可行产品)**

**目标**：搭建一个功能性的、非AI的教务信息查询工具。此阶段的产出是一个可以通过API稳定查询核心数据的后端服务和一个简单的Web展示界面。

**核心任务**:

1.  **环境搭建与安全准备**:
    *   与校方沟通，获取数据库的**只读访问权限**和数据表结构文档。
    *   在本地配置好Python、数据库（如MySQL/PostgreSQL）和代码编辑器（如VS Code）。
    *   使用`git`进行版本控制，并在GitHub或Gitee上创建项目仓库。

2.  **后端API开发 (数据服务层)**:
    *   使用 **Python + Flask** 框架。
    *   编写数据库连接模块，确保能安全地连接到学校数据库。
    *   创建一系列核心的 **RESTful API Endpoint**，这是整个项目的骨架。
        *   `GET /api/students/{student_id}/profile` (获取学生基本信息)
        *   `GET /api/students/{student_id}/scores` (获取所有成绩)
        *   `GET /api/students/{student_id}/credits_summary` (获取学分统计)
        *   `GET /api/courses/{course_id}` (获取课程详情)
        *   `GET /api/programs/{program_id}/requirements` (获取毕业要求)
    *   使用 Postman 或 Insomnia 等工具对每个API进行严格测试，确保数据返回正确。

3.  **前端界面开发 (表现层)**:
    *   使用纯 **HTML, CSS, JavaScript**。
    *   创建一个简单的登录页面（暂时可以用学号+固定密码模拟）。
    *   创建一个信息展示页面，上面有几个按钮，如“查询成绩”、“查询毕业进度”。
    *   编写JavaScript `fetch`函数，点击按钮时调用后端的API，并将返回的JSON数据显示在表格或列表中。

**阶段产出**: 一个可以实际运行的Web应用。虽然不“智能”，但已经能解决学生的核心查询需求。这是后续所有AI功能的数据基础。

---

#### **第二阶段：注入智能灵魂 (AI能力集成)**

**目标**：将第一阶段的工具升级为真正的“AI助手”，实现通过自然语言进行交互。

**核心任务**:

1.  **设计对话逻辑 (AI引擎层)**:
    *   确定助手需要理解的核心**意图 (Intents)**，如 `query_score`, `check_graduation`, `get_course_info`。
    *   确定需要从问句中提取的**实体 (Entities)**，如 `课程名`, `学期`, `课程类型`。

2.  **实现NLP引擎**:
    *   **方案A (快速入门)**: 使用 **Python编写基于规则和关键词的解析器**。例如，如果句子包含“成绩”和“高等数学”，就调用 `/api/students/{id}/scores` 并筛选“高等数学”的结果。
    *   **方案B (推荐)**: 引入开源NLP框架 **Rasa**。Rasa专门用于构建对话机器人，你可以定义NLU训练数据（告诉它各种问法对应的意图和实体），训练一个模型。Rasa可以管理对话状态，并根据识别出的意图调用你已经写好的API。

3.  **改造前端界面**:
    *   将按钮界面改造成一个**聊天窗口 (Chatbot UI)**。
    *   用户输入问题后，通过WebSocket或HTTP请求发送给后端AI引擎。
    *   接收后端返回的答案并显示在聊天窗口中。

**阶段产出**: 一个可以通过打字（或语音转文字）进行问答的AI教务助手。用户体验得到质的飞跃。

---

#### **第三阶段：高级功能与部署上线**

**目标**：增加预测性和规划性的高级AI功能，并把服务部署到服务器上，使其对全校学生可用。

**核心任务**:

1.  **开发高级AI功能**:
    *   **学业风险预警**: 使用 **Scikit-learn** 库。收集（匿名的）历史数据，训练一个分类模型（如逻辑回归），预测学生挂科风险。然后新增一个API `GET /api/students/{student_id}/academic_risk`。
    *   **毕业路径规划**: 这更多是**算法和逻辑问题**。你需要编写一个函数，它接收学生的已修课程和毕业要求，然后通过图算法或约束求解，计算出未来学期的最优选课方案。

2.  **完善安全与认证**:
    *   **必须实现！** 与学校的统一身份认证系统（如OAuth 2.0或CAS）对接，实现真正的安全登录。**绝不能使用自己做的简单密码系统上线。**
    *   配置 **HTTPS**。使用Nginx作为反向代理，并配置SSL证书（可以使用免费的Let's Encrypt）。

3.  **部署上线**:
    *   购买一台云服务器 (VPS)，如阿里云、腾讯云。
    *   使用 **Docker** 将你的Flask应用和数据库打包成容器，实现环境隔离和快速部署。
    *   使用 **Gunicorn** 作为WSGI服务器来运行你的Flask应用（比Flask自带的开发服务器性能好得多）。
    *   使用 **Nginx** 作为反向代理，接收外部请求并转发给Gunicorn。

**阶段产出**: 一个功能强大、安全可靠、可供全校师生公开访问的AI教务助手。

---

### 技术选型汇总表

| 组件/层面 | 推荐技术 | 理由 |
| :--- | :--- | :--- |
| **后端框架** | **Python 3 + Flask** | 语法简洁，生态丰富，轻量灵活，非常适合快速开发API和集成AI库。 |
| **数据库** | **MySQL / PostgreSQL** | 稳定、成熟的关系型数据库，大概率与学校现有系统一致。 |
| **数据库连接库** | `mysql-connector-python` / `psycopg2` | Python中连接对应数据库的标准库。 |
| **前端** | **HTML, CSS, JavaScript** | 基础技术，无需框架即可完成MVP。后期可按需引入**Vue.js**或**React**提升交互。 |
| **NLP引擎** | **Rasa** (推荐) 或 **自定义规则** | Rasa是构建对话式AI的专业开源框架，功能强大且易于扩展。自定义规则是更简单的起点。 |
| **机器学习** | **Scikit-learn** | Python中最流行、最全面的机器学习库，包含各类分类和回归模型，文档齐全。 |
| **应用服务器** | **Gunicorn** | 生产环境标准的WSGI服务器，用于运行Python Web应用，性能和稳定性远超开发服务器。 |
| **Web服务器** | **Nginx** | 高性能的反向代理服务器，用于处理静态文件、负载均衡和配置HTTPS。 |
| **容器化** | **Docker** | 实现“一次构建，到处运行”，极大简化部署流程，保证开发和生产环境一致。 |
| **版本控制** | **Git / GitHub** | 代码协作和版本管理的行业标准。 |
| **云服务器** | **阿里云 / 腾讯云 / AWS** | 提供稳定可靠的计算资源，可按需付费。 |

遵循这条路径，你可以由浅入深，步步为营地构建起一个强大、稳定且易于维护的AI教务助手。祝你项目顺利！

### 20250909
有了对话界面并和后端还有数据库打通之后，开始考虑加入真正的ai能力。

有以下三点改进之处：
- 引入更强的NLU引擎：将 process_query 函数中的 if/else 和正则表达式替换为真正的NLU框架（如Rasa, spaCy），使其能理解更复杂的语法和意图。
- 引入机器学习：收集数据后，你可以训练一个学业风险预测模型（使用Scikit-learn），并增加一个新的意图：“我下一门课挂科的风险高吗？”
- 接入大语言模型(LLM)：你可以将用户的复杂问题（如“帮我规划一下毕业前要修的课”）发送给GPT等大模型，并将结果格式化后返回给用户。

#### 引入RASA引擎
我们先理解一下Rasa的几个核心概念，这将让你对接下来的步骤有更清晰的认识：

1.  **NLU (Natural Language Understanding)** (`nlu.yml`): 这是Rasa的“耳朵”。你在这里提供大量例句，告诉Rasa不同的说法对应什么**意图 (Intent)**，并教会它识别句子中的**实体 (Entity)**。
    *   **意图**: 用户的目的。例如 `query_scores` (查成绩), `query_gpa` (查绩点)。
    *   **实体**: 句子中的关键信息。例如在“查一下我*高等数学*的成绩”中，`高等数学`就是一个`course_name`实体。

2.  **Domain (领域)** (`domain.yml`): 这是你助手的“地图”。它定义了助手知道的所有意图、实体、它可以说的所有话 (`responses`)，以及它可以执行的所有**动作 (Actions)**。

3.  **Stories (故事)** (`stories.yml`): 这是对话的“剧本”。你在这里编写用户和助手之间可能的对话流程样本，教会Rasa的**对话管理模型 (Core)**如何根据对话历史来决定下一步做什么。

4.  **Actions (动作)** (`actions/actions.py`): 这是Rasa的“手和脚”。当需要执行查询数据库、调用API等复杂逻辑时，就会触发一个自定义动作。**这正是Rasa与我们现有Flask API连接的桥梁。**

我们的系统将演变成这样：

**用户** ↔️ **前端 (index.html)** ↔️ **Rasa 服务器** ↔️ **Rasa Action 服务器** ↔️ **Flask API 服务器** ↔️ **数据库**

##### 环境
```
mkdir rasa_bot
cd rasa_bot
# 安装Rasa (这会安装很多依赖，可能需要一些时间)
pip install rasa
# 我们需要在Action服务器中调用API，所以安装requests库
pip install requests
```